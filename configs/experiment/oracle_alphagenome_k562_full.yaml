task_mode: human
head_arch: mlp-512-512
head_name: alphagenome_k562_head
num_tracks: 1

k562_data_path: data/k562
context_mode: alphagenome600

output_dir: outputs/oracle_alphagenome_k562_full
weights_path: checkpoints/alphagenome-jax-all_folds-v1
gpu: 0
epochs: 50
seed: null
wandb_mode: offline

batch_size: 128
num_workers: 4
max_seq_len: 600   # ignored when use_compact_window=true
# use_compact_window: true => full variable + flank slices only, fixed W; no N's in variable.
use_compact_window: false
flank_bp: 200
# compact_window_bp: null => W = min_var_len + 2*flank_bp (adaptive). Set to 384 for encoder-friendly fixed window.
compact_window_bp: null
lr: 0.001
weight_decay: 1e-6
gradients_clip: null
save_full_model: false
include_pool: false
subset_fraction: null
early_stop_patience: 5
val_eval_interval: 1
# no_shift = cache embeddings once, train head only (~20–50× faster). Use for rapid iteration.
# full = encoder every step + shift aug (production). hybrid = 50% cache / 50% encoder.
aug_mode: "no_shift"
cache_dir: null        # null = {output_dir}/embedding_cache

# Regularisation and LR scheduling (set in per-run SLURM scripts for ablations)
dropout_rate: 0.0       # 0.0 = no dropout. Use 0.1 to match FT_MPRA K562 reference.
lr_schedule: "none"     # "none" (constant) | "plateau" (reduce-on-plateau)
lr_plateau_patience: 5  # epochs without val Pearson improvement before reducing LR
lr_plateau_factor: 0.5  # multiply LR by this when plateau detected (floor = lr * 0.01)
